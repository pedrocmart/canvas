// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"context"
	"database/sql"
	"github.com/pedrocmart/canvas/internal/core"
	"sync"
)

// Ensure, that StoreMock does implement core.Store.
// If this is not the case, regenerate this file with moq.
var _ core.Store = &StoreMock{}

// StoreMock is a mock implementation of core.Store.
//
// 	func TestSomethingThatUsesStore(t *testing.T) {
//
// 		// make and configure a mocked core.Store
// 		mockedStore := &StoreMock{
// 			CanvasCreateFunc: func(contextMoqParam context.Context, s string) (string, error) {
// 				panic("mock out the CanvasCreate method")
// 			},
// 			CanvasGetByIDFunc: func(ctx context.Context, id string) (*core.Canvas, error) {
// 				panic("mock out the CanvasGetByID method")
// 			},
// 			DBFunc: func() *sql.DB {
// 				panic("mock out the DB method")
// 			},
// 		}
//
// 		// use mockedStore in code that requires core.Store
// 		// and then make assertions.
//
// 	}
type StoreMock struct {
	// CanvasCreateFunc mocks the CanvasCreate method.
	CanvasCreateFunc func(contextMoqParam context.Context, s string) (string, error)

	// CanvasGetByIDFunc mocks the CanvasGetByID method.
	CanvasGetByIDFunc func(ctx context.Context, id string) (*core.Canvas, error)

	// DBFunc mocks the DB method.
	DBFunc func() *sql.DB

	// calls tracks calls to the methods.
	calls struct {
		// CanvasCreate holds details about calls to the CanvasCreate method.
		CanvasCreate []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
			// S is the s argument value.
			S string
		}
		// CanvasGetByID holds details about calls to the CanvasGetByID method.
		CanvasGetByID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID string
		}
		// DB holds details about calls to the DB method.
		DB []struct {
		}
	}
	lockCanvasCreate  sync.RWMutex
	lockCanvasGetByID sync.RWMutex
	lockDB            sync.RWMutex
}

// CanvasCreate calls CanvasCreateFunc.
func (mock *StoreMock) CanvasCreate(contextMoqParam context.Context, s string) (string, error) {
	if mock.CanvasCreateFunc == nil {
		panic("StoreMock.CanvasCreateFunc: method is nil but Store.CanvasCreate was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
		S               string
	}{
		ContextMoqParam: contextMoqParam,
		S:               s,
	}
	mock.lockCanvasCreate.Lock()
	mock.calls.CanvasCreate = append(mock.calls.CanvasCreate, callInfo)
	mock.lockCanvasCreate.Unlock()
	return mock.CanvasCreateFunc(contextMoqParam, s)
}

// CanvasCreateCalls gets all the calls that were made to CanvasCreate.
// Check the length with:
//     len(mockedStore.CanvasCreateCalls())
func (mock *StoreMock) CanvasCreateCalls() []struct {
	ContextMoqParam context.Context
	S               string
} {
	var calls []struct {
		ContextMoqParam context.Context
		S               string
	}
	mock.lockCanvasCreate.RLock()
	calls = mock.calls.CanvasCreate
	mock.lockCanvasCreate.RUnlock()
	return calls
}

// CanvasGetByID calls CanvasGetByIDFunc.
func (mock *StoreMock) CanvasGetByID(ctx context.Context, id string) (*core.Canvas, error) {
	if mock.CanvasGetByIDFunc == nil {
		panic("StoreMock.CanvasGetByIDFunc: method is nil but Store.CanvasGetByID was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  string
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockCanvasGetByID.Lock()
	mock.calls.CanvasGetByID = append(mock.calls.CanvasGetByID, callInfo)
	mock.lockCanvasGetByID.Unlock()
	return mock.CanvasGetByIDFunc(ctx, id)
}

// CanvasGetByIDCalls gets all the calls that were made to CanvasGetByID.
// Check the length with:
//     len(mockedStore.CanvasGetByIDCalls())
func (mock *StoreMock) CanvasGetByIDCalls() []struct {
	Ctx context.Context
	ID  string
} {
	var calls []struct {
		Ctx context.Context
		ID  string
	}
	mock.lockCanvasGetByID.RLock()
	calls = mock.calls.CanvasGetByID
	mock.lockCanvasGetByID.RUnlock()
	return calls
}

// DB calls DBFunc.
func (mock *StoreMock) DB() *sql.DB {
	if mock.DBFunc == nil {
		panic("StoreMock.DBFunc: method is nil but Store.DB was just called")
	}
	callInfo := struct {
	}{}
	mock.lockDB.Lock()
	mock.calls.DB = append(mock.calls.DB, callInfo)
	mock.lockDB.Unlock()
	return mock.DBFunc()
}

// DBCalls gets all the calls that were made to DB.
// Check the length with:
//     len(mockedStore.DBCalls())
func (mock *StoreMock) DBCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockDB.RLock()
	calls = mock.calls.DB
	mock.lockDB.RUnlock()
	return calls
}
